// CS2100 Computer Organisation
// AY2024/2025 Semester 1
// National University of Singapore.
// Assignment 1 Question 1.
// All rights reserved.
//
// Start by filling in the following variables which main() will print out so as to identify yourself.
// Failure to full in the details correctly will be penalised.
//

const char *student_number = "A0282500R";
const char *student_name = "Wang Xiyu";
const char *student_tut_grp = "01";

#include <stdio.h>
#include <stdlib.h> // Provides the exit() function to abort.
/**
 * @brief This function will convert the integer input that is represented in two's complement 
 *        to one that is in one's complement, and return that as the result.
 *
 * @param x The 2's complement input integer to be converted.
 *
 * @return  The one's complement representation of x.
 *
 **/
int twos_to_ones(int x)     
{
    if (x >= 0) {
        return x;       // if positive, 1's comp is the same as 2's comp, no need to change
    }
    return ~(-x);       // if negative, invert bit which yields x - 1, representing the -1 
                        // when converting 2's comp to 1's comp
}

/**
 * @brief Converts an integer to its n-bit binary string representation.
 *
 * This function generates an n-bit sign-extended one's-complement binary
 * string representation of the given integer `i` and stores it in `s`.
 *
 * @param i The input integer to be converted.
 * @param n The number of bits required for the binary representation.
 * @param s Pointer to the output string where the binary representation
 *          will be stored. The space allocated for `s` must accommodate
 *          `n + 1` characters (including the null-terminator, i.e., 0). The MSB 
 *          is always at the zero'ed position of the string and the LSB 
 *          is the last character in the string before the null-terminator.
 *
 * @note The function assumes that the longest integer to be represented
 *       is 32 bits.
 *
 **/
void binstr(int i, int n, char *s) {
    int j;
    for (j = n - 1; j >= 0; j--) {
        s[j] = (i & 1) ? '1' : '0'; 
        i = i >> 1;
    }
    s[n] = '\0';
}

/**
 * @brief Converts an n-bit binary string to its corresponding integer value.
 *
 * This function reverses the operation of `binstr`, converting an n-character
 * long null-terminated binary string `s` in one's-complement form to its
 * corresponding integer value in two's complement representation.
 *
 * @param s Pointer to the input string representing the binary number in
 *          one's-complement form. The string is assumed to be exactly `n`
 *          characters long, followed by a null-terminator.
 * @param n The number of bits in the binary string (not including the
 *          null-terminator).
 *
 * @return The integer value corresponding to the binary string `s`.
 *
 * @note If `s` contains any character other than '0' or '1', or if `n`
 *       exceeds 32, the function will return an undefined (arbitrary) value.
 *
 **/
int str2int(char *s, int n)
{
    int res = 0;
    int is_negative = (s[0] == '1');  // Check if the number is negative (1's complement)
    int i, j;

    // Convert the binary string to integer by shifting and adding bits
    for (i = 0; i < n; i++) {
        res = (res << 1);  // Left shift result to make space for the new bit
        if (s[i] == '1') {
            res |= 1;  // Add the bit to the result
        }
    }

    // If it's a negative number in 1's complement form, flip the bits
    if (is_negative) {
        res = ~res;  // Flip the bits (One's complement rule)

    }
    int power = 1;
    for (j = 0; j < n; j++) {
        power = power << 1;
    }
    return is_negative ? - (power + res) : res;  // Return the correct signed value
}

/**
 * @brief Validates whether the input integer `x` fits within an n-bit
 *        one's-complement representation.
 *
 * This function checks if the input integer `x` can be represented within
 * an n-bit one's-complement format. If `x` fits, the function returns 0.
 * If `x` is out of range, the function returns the nearest limit, which
 * will be negative if `x` is negative.
 *
 * @param x The input integer to be validated.
 * @param n The number of bits for the one's-complement representation.
 *
 * @return 0 if `x` fits within the n-bit one's-complement range, otherwise
 *         the nearest limit is returned.
 *
 **/
int validate_1s_complement(int x, int n)
{
    if (n <= 0 || n > 32) {
        return -1;  
    }

    int min_val = -(1 << (n - 1)); 
    int max_val = (1 << (n - 1)) - 1;  

    if (x >= min_val && x <= max_val) {
        return 0;  
    }

    return (x < min_val) ? min_val : max_val; 
}

/**
 * @brief Checks for carry out of the MSB by checking the carry string.
 *
 * @param carry_str The (n+1) character carry string generated by the addition
 *                  process.
 * @param n The number of bits for the one's-complement representation.
 *
 * @return 0 if the MSB of the carry string is the character '0'.
 * @return 1 if the MSB of the carry string is the character '1'.
 *
 **/
int check_carryout(char *carry_str)
{
    return carry_str[0] == '1' ? 1 : 0;  
}

/**
 * @brief Checks for overflow after one's complement addition inspecting the 
 *        two inputs (as strings) and the output (as a string). 
 *
 * @param op1 A n-character long null-terminated string of '0' and '1' representing the first
 *            operand of the addition. 
 *
 * @param op2 A n-character long null-terminated string of '0' and '1' representing the second 
 *            operand of the addition. 
 *
 * @param sum A n-character long null-terminated string of '0' and '1' representing the sum
 *            (i.e., result) of the addition. 
 *
 * @return 0 if there is no overflow.
 * @return 1 if there is an overflow.
 *
 * @note The three inputs must be of the same length.
 *
 **/
int check_overflow(char *op1, char *op2, char *sum)
{
    if ((op1[0] == op2[0]) && (op1[0] != sum[0])) {
        return 1; 
    }
    return 0;
}

/**
 * @brief Performs n-bit unsigned addition of two binary strings.
 *
 * This function adds two n-bit unsigned binary numbers represented by the
 * strings `x` and `y`. The result is stored in the string `z`, and the carry
 * out of each bit position is stored in the string `c`.
 *
 * @param n The number of bits in the input strings `x` and `y`.
 *
 * @param x Pointer to the first input binary string. The string is assumed
 *          to be `n` characters long, followed by a null-terminator.
 *
 * @param y Pointer to the second input binary string. The string is assumed
 *          to be `n` characters long, followed by a null-terminator.
 *
 * @param z Pointer to the output string where the result will be stored.
 *          The space allocated for `z` must accommodate `n` characters and
 *          a null-terminator.
 *
 * @param c Pointer to the output string where the carry bits will be stored.
 *          The space allocated for `c` must accommodate `n + 1` characters
 *          (including the carry out and the null-terminator).
 *
 * @return 0 if the operation is successful, -1 if any error occurs.
 *
 * @note The function assumes that the input strings `x` and `y` consist
 *       only of the characters '0' and '1'.
 *
 * @note The MSB is always at the zero'ed position of the string representing
 *       the ones-complement number, and the LSB is the last character in that 
 *       string before the null-terminator.
 *
 **/
int perform_addition(int n, char *x, char *y, char *z, char *c)
{
    int carry = 0;
    char *px = x + n - 1;  
    char *py = y + n - 1;  
    char *pz = z + n - 1;  
    char *pc = c + n;  

    z[n] = '\0';
    c[n + 1] = '\0';

    for (int i = 0; i < n; i++) {
        int bit1 = *px - '0';  
        int bit2 = *py - '0';  
        int sum = bit1 + bit2 + carry;  
        *pz = (sum % 2) ? '1' : '0'; 
        carry = sum / 2; 
        if (i == 0) {
            *pc = carry ? '0' : *px == '1' ? '1' : '0';
        } else {
            *pc = carry ? '1' : '0'; 
        }
        px--;
        py--;
        pz--;
        pc--;
    }
    *pc = carry ? '1' : '0';  
    return check_carryout(c);
}

int main(int argc, char *argv[])
{
    int x, y, z, n, check;
    int x1s, y1s;
    char x_str[33], y_str[33], z1_str[33], z2_str[33], one_str[33]; 
    char c1_str[34], c2_str[34]; // Holds the carries. It is 33 bits because the MSB is the carry out.

    printf("CS2100 Assignment 1 Question 1\n");
    printf("------------------------------\n");
    printf("One's complement addition submission by:\n\n");
    printf("Student name: %s\n", student_name);
    printf("Student number: %s\n", student_number);
    printf("Tutorial group: %s\n", student_tut_grp);
    printf("======================================\n");
    printf("How many bits do you want to do this in (must be [2, 32])? ");
    scanf("%d", &n);

    // Check if n is valid.
    if ((n < 2) || (n>33)) {
       printf("Invalid number of bits. Unable to proceed. Exiting...\n");
       exit(-1);
    }

    printf("\nInput your first number (as signed decimal): ");
    scanf("%d", &x);

    // Check that x will fit into n bits. Note that y here is still in two's complement.
    check = validate_1s_complement(x, n); 

    if (check) {
       printf("\nSorry, but %d exceeds the range of a %d-bit one's complement representation. The limit is %d. Exiting...\n",
              x, n, check);
       exit(-1);
    }

    // The input x is in two's complement. Need to convert it to the one's complement equivalent.
    x1s = twos_to_ones(x);

    printf("\nInput your second number (as signed decimal): ");
    scanf("%d", &y);

    // Check that y will fit into n bits. Note that y here is still in two's complement.
    check = validate_1s_complement(y, n); 

    if (check) {
       printf("\nSorry, but %d exceeds the range of a %d-bit one's complement representation. The limit is %d. Exiting...\n",
              y, n, check);
       exit(-1);
    }

    // The input y is in two's complement. Need to convert it to the one's complement equivalent.
    y1s = twos_to_ones(y);

    printf("\nThe one's complement addition process is as follows:\n\n");

    binstr(x1s, n, x_str);

    binstr(y1s, n, y_str);

    perform_addition(n, x_str, y_str, z1_str, c1_str);

    // Print what we had achieved so far.
    printf("X:   %s (%d)\n", x_str, x);
    printf("Y:   %s (%d) +\n", y_str, y);

    for (int k=0; k<n; k++)
        printf("-");
    printf("----------------\n");

    printf("C1: %s\n", c1_str);
    printf("Z1:  %s (%d)", z1_str, str2int(z1_str, n));

    if (check_carryout(c1_str)) { // Carry out!

       printf("\n");

       binstr(1, n, one_str);

       perform_addition(n, z1_str, one_str, z2_str, c2_str);

       printf("     %s +       <-- due to carry out\n", one_str);

       for (int k=0; k<n; k++)
           printf("-");
       printf("----------------\n");

       printf("C2: %s\n", c2_str);
       printf("Z2:  %s", z2_str); 
 
       // Check for overflow
       if (check_overflow(x_str, y_str, z2_str)) {
          printf("\nRESULT OVERFLOWED!!!\n");
          exit(-1);
       }

       // Everything correct. Print out the decimal value of the result.
       printf(" (%d) [FINAL ANSWER in one's complement]\n", str2int(z2_str, n));
    } else { // No carry out

       // Check for overflow
       if (check_overflow(x_str, y_str, z1_str)) {
          printf("\nRESULT OVERFLOWED!!!\n");
          exit(-1);
       }

       printf(" [FINAL ANSWER in one's complement]\n");
    }

    printf("\n");
}
